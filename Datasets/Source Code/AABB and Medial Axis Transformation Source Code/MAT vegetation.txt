#include <iostream>
#include <vector>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/search/kdtree.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <thread>
#include <chrono>
#include <limits>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>

using PointT = pcl::PointXYZ;
using PointCloudPtr = pcl::PointCloud<PointT>::Ptr;
using KdTreePtr = pcl::search::KdTree<PointT>::Ptr;

// Connect skeleton points using Minimum Spanning Tree (MST)
std::vector<pcl::Vertices> mstConnection(PointCloudPtr skeleton) {
    std::vector<pcl::Vertices> lines;
    if (skeleton->size() < 2) return lines;

    // Build KDTree to accelerate search
    KdTreePtr tree(new pcl::search::KdTree<PointT>);
    tree->setInputCloud(skeleton);

    // Data structures required for Prim's algorithm
    std::vector<bool> inMST(skeleton->size(), false);       // Whether the point has been added to MST
    std::vector<float> minDist(skeleton->size(), std::numeric_limits<float>::max());  // Minimum distance to MST
    std::vector<int> parent(skeleton->size(), -1);          // Parent node index

    // Start building from the first point
    minDist[0] = 0.0f;

    for (size_t i = 0; i < skeleton->size(); ++i) {
        // Find the point closest to the MST
        int u = -1;
        float minVal = std::numeric_limits<float>::max();
        for (size_t j = 0; j < skeleton->size(); ++j) {
            if (!inMST[j] && minDist[j] < minVal) {
                minVal = minDist[j];
                u = j;
            }
        }

        if (u == -1) break;  // Cannot continue building
        inMST[u] = true;

        // Update distances to neighboring points
        std::vector<int> neighbors;
        std::vector<float> dists;
        if (tree->radiusSearch(u, 1.0f, neighbors, dists) > 0) {  // Search radius: 1.0f
            for (size_t j = 0; j < neighbors.size(); ++j) {
                int v = neighbors[j];
                if (!inMST[v] && dists[j] < minDist[v]) {
                    minDist[v] = dists[j];
                    parent[v] = u;
                }
            }
        }
    }

    // Generate connection lines
    for (size_t i = 1; i < skeleton->size(); ++i) {
        if (parent[i] != -1) {
            pcl::Vertices line;
            line.vertices = { parent[i], static_cast<int>(i) };
            lines.push_back(line);
        }
    }
    return lines;
}

// Visualization function
void visualize(PointCloudPtr original, PointCloudPtr skeleton, const std::vector<pcl::Vertices>& lines) {
    pcl::visualization::PCLVisualizer viewer("MST Skeleton Connection");
    viewer.setBackgroundColor(0, 0, 0);

    // Original point cloud (gray with low opacity)
    viewer.addPointCloud(original, pcl::visualization::PointCloudColorHandlerCustom<PointT>(original, 200, 200, 200), "original");
    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "original");
    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_OPACITY, 0.2, "original");

    // Skeleton points (red)
    viewer.addPointCloud(skeleton, pcl::visualization::PointCloudColorHandlerCustom<PointT>(skeleton, 255, 0, 0), "skeleton");
    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 4, "skeleton");

    // Connection lines (green)
    for (size_t i = 0; i < lines.size(); ++i) {
        std::string id = "line_" + std::to_string(i);
        viewer.addLine(skeleton->points[lines[i].vertices[0]], skeleton->points[lines[i].vertices[1]], 0, 1, 0, id);
        viewer.setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_LINE_WIDTH, 2, id);
    }

    viewer.addCoordinateSystem(1.0);
    while (!viewer.wasStopped()) {
        viewer.spinOnce(100);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

// Skeleton point extraction (simplified distance transform method)
PointCloudPtr extractSkeletonPoints(PointCloudPtr cloud) {
    // In practical applications, this can be replaced with a more accurate skeleton extraction algorithm
    PointCloudPtr skeleton(new pcl::PointCloud<PointT>);
    pcl::VoxelGrid<PointT> voxel;
    voxel.setInputCloud(cloud);
    voxel.setLeafSize(0.05f, 0.05f, 0.05f);
    voxel.filter(*skeleton);
    return skeleton;
}

int main() {
    // Read point cloud
    PointCloudPtr cloud(new pcl::PointCloud<PointT>);
    std::string inputPath = "C:\\Users\\admin\\Desktop\\1\\点云实验\\plant.pcd";
    if (pcl::io::loadPCDFile(inputPath, *cloud) == -1) {
        PCL_ERROR("Failed to read file: %s\n", inputPath.c_str());
        return -1;
    }

    // Extract skeleton points
    PointCloudPtr skeleton = extractSkeletonPoints(cloud);
    std::cout << "Number of skeleton points: " << skeleton->size() << std::endl;

    // MST connection
    std::vector<pcl::Vertices> lines = mstConnection(skeleton);
    std::cout << "Number of MST connection lines: " << lines.size() << std::endl;

    // Visualization
    visualize(cloud, skeleton, lines);
    return 0;
}