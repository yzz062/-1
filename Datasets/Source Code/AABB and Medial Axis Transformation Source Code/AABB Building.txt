#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/common/common.h>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <boost/thread/thread.hpp>

struct BoundingBox {
    pcl::PointXYZ min_point;
    pcl::PointXYZ max_point;
    std::vector<pcl::PointXYZ> vertices;
};

void calculateBoundingBox(const pcl::PointCloud<pcl::PointXYZ>::Ptr& cloud,
    BoundingBox& bbox) {
    pcl::getMinMax3D(*cloud, bbox.min_point, bbox.max_point);

    // 生成8个顶点
    bbox.vertices.resize(8);
    bbox.vertices[0] = pcl::PointXYZ(bbox.min_point.x, bbox.min_point.y, bbox.min_point.z);
    bbox.vertices[1] = pcl::PointXYZ(bbox.max_point.x, bbox.min_point.y, bbox.min_point.z);
    bbox.vertices[2] = pcl::PointXYZ(bbox.max_point.x, bbox.max_point.y, bbox.min_point.z);
    bbox.vertices[3] = pcl::PointXYZ(bbox.min_point.x, bbox.max_point.y, bbox.min_point.z);
    bbox.vertices[4] = pcl::PointXYZ(bbox.min_point.x, bbox.min_point.y, bbox.max_point.z);
    bbox.vertices[5] = pcl::PointXYZ(bbox.max_point.x, bbox.min_point.y, bbox.max_point.z);
    bbox.vertices[6] = pcl::PointXYZ(bbox.max_point.x, bbox.max_point.y, bbox.max_point.z);
    bbox.vertices[7] = pcl::PointXYZ(bbox.min_point.x, bbox.max_point.y, bbox.max_point.z);
}

void exportBoxesToCSV(const std::vector<BoundingBox>& boxes,
    const std::string& filename) {
    std::ofstream outfile(filename);
    outfile << "BoxID,VertexID,X,Y,Z,MinX,MinY,MinZ,MaxX,MaxY,MaxZ\n";

    for (size_t i = 0; i < boxes.size(); ++i) {
        const auto& box = boxes[i];
        for (size_t j = 0; j < box.vertices.size(); ++j) {
            outfile << i << "," << j << ","
                << box.vertices[j].x << "," << box.vertices[j].y << "," << box.vertices[j].z << ","
                << box.min_point.x << "," << box.min_point.y << "," << box.min_point.z << ","
                << box.max_point.x << "," << box.max_point.y << "," << box.max_point.z << "\n";
        }
    }
    outfile.close();
}

int main(int argc, char** argv) {
    // 1. 加载点云
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
    if (pcl::io::loadPCDFile<pcl::PointXYZ>("dl.pcd", *cloud) == -1) {
        PCL_ERROR("Couldn't read input file\n");
        return -1;
    }

    // 2. 体素化分块
    float leaf_size = 0.4f;
    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;
    voxel_grid.setInputCloud(cloud);
    voxel_grid.setLeafSize(leaf_size, leaf_size, leaf_size);

    std::unordered_map<std::string, pcl::PointCloud<pcl::PointXYZ>::Ptr> voxel_clouds;
    std::vector<BoundingBox> bounding_boxes;

    // 3. 生成体素块
    for (const auto& point : cloud->points) {
        std::string voxel_id =
            std::to_string(static_cast<int>(point.x / leaf_size)) + "_" +
            std::to_string(static_cast<int>(point.y / leaf_size)) + "_" +
            std::to_string(static_cast<int>(point.z / leaf_size));

        if (voxel_clouds.find(voxel_id) == voxel_clouds.end()) {
            voxel_clouds[voxel_id] = pcl::PointCloud<pcl::PointXYZ>::Ptr(
                new pcl::PointCloud<pcl::PointXYZ>);
        }
        voxel_clouds[voxel_id]->push_back(point);
    }

    // 4. 为每个体素块计算包围盒
    for (const auto& pair : voxel_clouds) {
        BoundingBox bbox;
        calculateBoundingBox(pair.second, bbox);
        bounding_boxes.push_back(bbox);
    }

    // 5. 导出包围盒数据
    exportBoxesToCSV(bounding_boxes, "bounding_boxes.csv");

    // 6. 可视化
    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer(
        new pcl::visualization::PCLVisualizer("3D Viewer"));
    viewer->addPointCloud<pcl::PointXYZ>(cloud, "cloud");

    for (size_t i = 0; i < bounding_boxes.size(); ++i) {
        const auto& bbox = bounding_boxes[i];
        viewer->addCube(bbox.min_point.x, bbox.max_point.x,
            bbox.min_point.y, bbox.max_point.y,
            bbox.min_point.z, bbox.max_point.z,
            1.0, 0.0, 0.0, "bbox_" + std::to_string(i));
    }

    while (!viewer->wasStopped()) {
        viewer->spinOnce(100);
        boost::this_thread::sleep(boost::posix_time::microseconds(100000));
    }

    return 0;
}