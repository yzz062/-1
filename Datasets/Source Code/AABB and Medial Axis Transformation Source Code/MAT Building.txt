#include <iostream>
#include <thread>
#include <chrono>
#include <vector>
#include <algorithm>
#include <cmath>  // 用于数学计算
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/features/boundary.h>
#include <pcl/features/normal_3d.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/filters/radius_outlier_removal.h>
#include <pcl/search/kdtree.h>
#include <pcl/common/common.h>

// 自定义角度转换函数（替代PCL的rad2deg，解决头文件缺失问题）
inline float rad2deg(float radians) {
    return radians * (180.0f / static_cast<float>(M_PI));
}

// 类型别名（减少指针复制开销）
using PointCloudPtr = pcl::PointCloud<pcl::PointXYZ>::Ptr;
using KdTreePtr = pcl::search::KdTree<pcl::PointXYZ>::Ptr;

// 点云统计特征（包含角度敏感性参数）
struct CloudStats {
    float max_dim;         // 最大维度
    float avg_spacing;     // 平均点间距
    float angle_sensitivity;  // 角度特征敏感度（斜度边适配）
};

// 计算点云统计特征（针对大数据量优化采样）
CloudStats computeCloudStats(PointCloudPtr cloud) {
    // 基础尺度计算（快速获取边界）
    pcl::PointXYZ min_pt, max_pt;
    pcl::getMinMax3D(*cloud, min_pt, max_pt);
    float dim_x = max_pt.x - min_pt.x;
    float dim_y = max_pt.y - min_pt.y;
    float dim_z = max_pt.z - min_pt.z;
    float max_dim = std::max({ dim_x, dim_y, dim_z });

    // 大数据量专用采样策略（极少样本估算）
    KdTreePtr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud(cloud);
    float total_dist = 0.0f;
    int count = 0;
    // 八十万点优化：大幅降低采样密度（每20000点采样1个）
    size_t sample_step = std::max<size_t>(200, cloud->size() / 20000);

    for (size_t i = 0; i < cloud->size(); i += sample_step) {
        std::vector<int> indices(2);
        std::vector<float> dists(2);
        if (tree->nearestKSearch(i, 2, indices, dists) == 2) {
            total_dist += std::sqrt(dists[1]);
            count++;
        }
    }
    // 八十万点优化：增大默认间距，减少后续计算量
    float avg_spacing = count > 0 ? total_dist / count : 0.15f;

    // 八十万点优化：极致降低角度敏感度，减少角度计算开销
    float angle_sensitivity = std::min(0.2f, 0.03f / avg_spacing);

    return { max_dim, avg_spacing, angle_sensitivity };
}

// 计算点的局部角度特征（简化计算）
float computeLocalAngleFeature(const pcl::PointXYZ& point, PointCloudPtr cloud, KdTreePtr tree, float search_radius) {
    std::vector<int> neighbors;
    std::vector<float> dists;
    // 大数据量邻点要求（仅需2个，减少搜索时间）
    if (tree->radiusSearch(point, search_radius, neighbors, dists) < 2)
        return 0.0f;

    // 简化主方向计算（减少矩阵运算开销）
    Eigen::Vector4f centroid;
    pcl::compute3DCentroid(*cloud, neighbors, centroid);
    Eigen::Matrix3f covariance;
    pcl::computeCovarianceMatrixNormalized(*cloud, neighbors, centroid, covariance);
    Eigen::SelfAdjointEigenSolver<Eigen::Matrix3f> solver(covariance);
    Eigen::Vector3f eigen_vectors = solver.eigenvectors().col(0);  // 仅用主方向

    // 简化角度计算
    float angle_x = rad2deg(std::acos(std::min(1.0f, std::abs(eigen_vectors.x()))));  // 防越界优化
    float angle_y = rad2deg(std::acos(std::min(1.0f, std::abs(eigen_vectors.y()))));
    return std::max(angle_x, angle_y);
}

// 优化的边界点提取（大数据量专用降采样）
PointCloudPtr extractBoundaryPoints(PointCloudPtr cloud, const CloudStats& stats) {
    // 八十万点优化：大幅增大体素尺寸，极致缩减点数
    float voxel_size = std::max(15 * stats.avg_spacing, 0.15f);
    PointCloudPtr cloud_downsampled(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::VoxelGrid<pcl::PointXYZ> voxelGrid;
    voxelGrid.setInputCloud(cloud);
    voxelGrid.setLeafSize(voxel_size, voxel_size, voxel_size);
    voxelGrid.filter(*cloud_downsampled);
    std::cout << "降采样后点数: " << cloud_downsampled->size() << std::endl;

    // 八十万点优化：大幅减少法向量计算邻点数量
    int normal_k = std::min(6, (int)(2 / stats.avg_spacing));
    pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
    pcl::PointCloud<pcl::Normal>::Ptr normals(new pcl::PointCloud<pcl::Normal>);
    KdTreePtr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud(cloud_downsampled);

    ne.setInputCloud(cloud_downsampled);
    ne.setSearchMethod(tree);
    ne.setKSearch(normal_k);
    ne.compute(*normals);

    // 边界提取（最小邻点搜索）
    pcl::BoundaryEstimation<pcl::PointXYZ, pcl::Normal, pcl::Boundary> be;
    pcl::PointCloud<pcl::Boundary>::Ptr boundaries(new pcl::PointCloud<pcl::Boundary>);

    be.setInputCloud(cloud_downsampled);
    be.setInputNormals(normals);
    be.setSearchMethod(tree);
    // 八十万点优化：进一步减少边界提取邻点
    be.setKSearch(std::min(10, normal_k + 1));
    be.setAngleThreshold(M_PI / 2.5);  // 更低敏感度，减少边界点
    be.compute(*boundaries);

    // 提取边界点（极高角度阈值，减少点数）
    PointCloudPtr boundary_points(new pcl::PointCloud<pcl::PointXYZ>);
    KdTreePtr angle_tree(new pcl::search::KdTree<pcl::PointXYZ>);
    angle_tree->setInputCloud(cloud_downsampled);
    // 八十万点优化：增大角度搜索半径，减少重复计算
    float angle_search_radius = std::max(15 * stats.avg_spacing, 0.25f);

    for (size_t i = 0; i < cloud_downsampled->size(); ++i) {
        float local_angle = computeLocalAngleFeature(
            cloud_downsampled->points[i], cloud_downsampled, angle_tree, angle_search_radius);

        // 八十万点优化：提高角度阈值，仅保留明显特征点
        if (boundaries->points[i].boundary_point || local_angle > 60.0f) {
            boundary_points->push_back(cloud_downsampled->points[i]);
        }
    }

    // 离群点过滤（大数据量专用参数）
    pcl::RadiusOutlierRemoval<pcl::PointXYZ> outlier_removal;
    outlier_removal.setInputCloud(boundary_points);
    // 八十万点优化：增大离群点过滤半径，减少保留点
    outlier_removal.setRadiusSearch(std::max(15 * stats.avg_spacing, 0.4f));
    outlier_removal.setMinNeighborsInRadius(1);
    outlier_removal.filter(*boundary_points);

    return boundary_points;
}

// 优化的点云细化（大数据量骨架精简）
PointCloudPtr thinCloud(PointCloudPtr cloud, const CloudStats& stats, int iterations = 1) {
    PointCloudPtr thinned_cloud(new pcl::PointCloud<pcl::PointXYZ>(*cloud));
    KdTreePtr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    // 八十万点优化：增大搜索半径，减少搜索次数
    float search_radius = std::max(15 * stats.avg_spacing, 0.2f);
    // 八十万点优化：降低最小保留点数比例
    size_t min_keep = std::max<size_t>(3, cloud->size() * 0.003);

    KdTreePtr angle_tree(new pcl::search::KdTree<pcl::PointXYZ>);
    angle_tree->setInputCloud(thinned_cloud);
    // 八十万点优化：增大角度搜索半径
    float angle_search_radius = std::max(15 * stats.avg_spacing, 0.25f);

    for (int iter = 0; iter < iterations; ++iter) {
        PointCloudPtr temp_cloud(new pcl::PointCloud<pcl::PointXYZ>);
        tree->setInputCloud(thinned_cloud);
        angle_tree->setInputCloud(thinned_cloud);

        for (size_t j = 0; j < thinned_cloud->size(); ++j) {
            float local_angle = computeLocalAngleFeature(
                thinned_cloud->points[j], thinned_cloud, angle_tree, angle_search_radius);

            std::vector<int> neighbors;
            std::vector<float> dists;
            tree->radiusSearch(j, search_radius, neighbors, dists);

            // 八十万点优化：更严格的细化策略
            if (local_angle > 60.0f) {  // 仅保留更高角度点
                temp_cloud->push_back(thinned_cloud->points[j]);
            }
            else if (neighbors.size() <= 8) {  // 更严格的孤立点判断
                temp_cloud->push_back(thinned_cloud->points[j]);
            }
            else if (neighbors.size() < 20) {  // 中等密度区域更少保留
                if (j % 8 == 0) {  // 更大间隔保留
                    temp_cloud->push_back(thinned_cloud->points[j]);
                }
            }
            else {  // 高密度区域极严格过滤
                if (j % 15 == 0) {  // 更大间隔保留
                    temp_cloud->push_back(thinned_cloud->points[j]);
                }
            }
        }

        thinned_cloud = temp_cloud;
        if (thinned_cloud->size() < min_keep) break;  // 防止过度精简
    }

    return thinned_cloud;
}

// 优化的骨架线计算（大数据量线条精简）
std::vector<pcl::Vertices> computeSkeletonLines(PointCloudPtr skeleton, const CloudStats& stats) {
    std::vector<pcl::Vertices> lines;
    if (skeleton->size() < 2) return lines;

    KdTreePtr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud(skeleton);
    // 八十万点优化：增大基础距离，减少搜索次数
    float base_dist = stats.max_dim * 0.15f;
    // 八十万点优化：增大角度搜索半径
    float angle_search_radius = std::max(15 * stats.avg_spacing, 0.25f);

    for (size_t i = 0; i < skeleton->size(); ++i) {
        float local_angle = computeLocalAngleFeature(
            skeleton->points[i], skeleton, tree, angle_search_radius);
        // 八十万点优化：降低角度对距离的影响权重
        float dynamic_dist = base_dist * (1.0f + std::min(0.15f, local_angle / 90.0f * stats.angle_sensitivity));

        std::vector<int> neighbors;
        std::vector<float> dists;
        if (tree->radiusSearch(i, dynamic_dist, neighbors, dists) <= 1) continue;

        int count = 0;
        int max_connections = 1;  // 所有点仅连1条线，极致减少线条
        for (size_t j = 0; j < neighbors.size() && count < max_connections; ++j) {
            int neighbor_idx = neighbors[j];
            // 八十万点优化：过滤更多短线
            if (neighbor_idx > static_cast<int>(i) && dists[j] > 0.06f) {
                pcl::Vertices line;
                line.vertices.push_back(static_cast<int>(i));
                line.vertices.push_back(neighbor_idx);
                lines.push_back(line);
                count++;
            }
        }
    }

    return lines;
}

// 可视化优化（大数据量轻量渲染）
void visualizeSkeletonLines(PointCloudPtr skeleton, std::vector<pcl::Vertices> lines, const CloudStats& stats) {
    pcl::visualization::PCLVisualizer viewer("骨架线（大数据量模式）");
    viewer.setBackgroundColor(1, 1, 1);  // 背景色改为白色
    viewer.removeAllPointClouds();  // 清空默认渲染，减少开销

    // 极简球体渲染（仅显示关键骨架点）
    KdTreePtr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud(skeleton);
    float angle_search_radius = std::max(15 * stats.avg_spacing, 0.25f);

    for (size_t i = 0; i < skeleton->size(); ++i) {
        float local_angle = computeLocalAngleFeature(
            skeleton->points[i], skeleton, tree, angle_search_radius);
        float r = std::min(1.0f, local_angle / 120.0f);  // 降低颜色计算复杂度
        float g = 1.0f - r;
        std::string id = "point_" + std::to_string(i);
        // 八十万点优化：进一步缩小球体尺寸，减少渲染负载
        viewer.addSphere(skeleton->points[i], 0.004f, r, g, 0, id);
    }

    // 最细线宽渲染
    for (size_t i = 0; i < lines.size(); ++i) {
        if (lines[i].vertices.size() >= 2) {
            int idx1 = lines[i].vertices[0];
            int idx2 = lines[i].vertices[1];
            std::string line_id = "line_" + std::to_string(i);
            viewer.addLine<pcl::PointXYZ>(
                skeleton->points[idx1],
                skeleton->points[idx2],
                0.0f, 0.0f, 1.0f,  // 连接线颜色为蓝色
                line_id
            );
            viewer.setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_LINE_WIDTH, 0.2, line_id);
        }
    }

    viewer.addCoordinateSystem(1.0);
    viewer.initCameraParameters();
    viewer.resetCamera();

    // 八十万点优化：降低刷新频率，减少资源占用
    while (!viewer.wasStopped()) {
        viewer.spinOnce(250);  // 刷新间隔延长至250ms
        std::this_thread::sleep_for(std::chrono::milliseconds(250));
    }
}

// 原始点云可视化（大数据量极简模式）
void visualizeOriginalCloud(PointCloudPtr cloud) {
    pcl::visualization::PCLVisualizer viewer("原始点云（大数据量精简模式）");
    viewer.setBackgroundColor(1, 1, 1);  // 背景色改为白色

    // 八十万点优化：更早进行可视化降采样
    PointCloudPtr vis_cloud(new pcl::PointCloud<pcl::PointXYZ>);
    if (cloud->size() > 300000) {  // 阈值降低，更早触发降采样
        pcl::VoxelGrid<pcl::PointXYZ> vis_filter;
        vis_filter.setInputCloud(cloud);
        vis_filter.setLeafSize(0.6f, 0.6f, 0.6f);  // 增大可视化降采样体素
        vis_filter.filter(*vis_cloud);
        std::cout << "原始点云可视化降采样后点数: " << vis_cloud->size() << std::endl;
    }
    else {
        vis_cloud = cloud;
    }

    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> cloudColor(vis_cloud, 50, 50, 50);
    viewer.addPointCloud(vis_cloud, cloudColor, "original_cloud");
    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "original_cloud");
    // 八十万点优化：进一步降低原始点云透明度，减少渲染压力
    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_OPACITY, 0.005, "original_cloud");
    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_LUT, 0, "original_cloud");

    viewer.initCameraParameters();
    viewer.resetCamera();

    // 八十万点优化：降低刷新频率
    while (!viewer.wasStopped()) {
        viewer.spinOnce(250);
        std::this_thread::sleep_for(std::chrono::milliseconds(250));
    }
}

int main(int argc, char** argv) {
    // 大数据量处理优化：限制内存使用
    std::cout << "启用大数据量处理模式（八十万点优化）" << std::endl;
    std::string inputFileName = "C:\\Users\\admin\\Desktop\\1\\点云实验\\daoluSG3.pcd";
    std::string outputFileName = "skeleton.pcd";

    if (argc >= 2) inputFileName = argv[1];
    if (argc >= 3) outputFileName = argv[2];

    // 读取点云（启用二进制加速读取）
    PointCloudPtr cloud(new pcl::PointCloud<pcl::PointXYZ>);
    if (pcl::io::loadPCDFile(inputFileName, *cloud) == -1) {
        PCL_ERROR("无法读取PCD文件！\n");
        return -1;
    }
    std::cout << "成功读取点云，原始点数: " << cloud->size() << std::endl;

    // 计算点云统计特征（快速估算）
    CloudStats stats = computeCloudStats(cloud);
    std::cout << "点云尺度: 最大维度=" << stats.max_dim
        << "m, 平均点间距=" << stats.avg_spacing << "m" << std::endl;

    // 提取边界点（大幅缩减数据量）
    PointCloudPtr boundary_points = extractBoundaryPoints(cloud, stats);
    std::cout << "提取边界点数量: " << boundary_points->size() << std::endl;

    // 骨架细化（极致精简）
    PointCloudPtr skeleton = thinCloud(boundary_points, stats, 1);  // 仅1次迭代，减少计算
    std::cout << "骨架点数量: " << skeleton->size() << std::endl;

    // 生成骨架线（最少线条）
    std::vector<pcl::Vertices> skeleton_lines = computeSkeletonLines(skeleton, stats);
    std::cout << "生成骨架线段数量: " << skeleton_lines.size() << std::endl;

    // 保存结果（二进制格式加速）
    if (pcl::io::savePCDFileBinary(outputFileName, *skeleton) == -1) {  // 二进制保存更快
        PCL_ERROR("无法保存骨架点云文件！\n");
        return -1;
    }
    std::cout << "骨架点云已保存到: " << outputFileName << std::endl;

    // 可视化（可选：可注释掉以加速运行）
    std::thread original_thread(&visualizeOriginalCloud, cloud);
    std::thread skeleton_thread(&visualizeSkeletonLines, skeleton, skeleton_lines, stats);

    original_thread.join();
    skeleton_thread.join();

    return 0;
}