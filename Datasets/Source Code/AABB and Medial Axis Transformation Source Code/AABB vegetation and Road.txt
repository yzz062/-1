#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/common/common.h>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <boost/thread/thread.hpp>
#include <cmath>

struct BoundingBox {
    pcl::PointXYZ min_point;
    pcl::PointXYZ max_point;
    std::vector<pcl::PointXYZ> vertices;
};

void calculateBoundingBox(const pcl::PointCloud<pcl::PointXYZ>::Ptr& cloud,
    BoundingBox& bbox) {
    pcl::getMinMax3D(*cloud, bbox.min_point, bbox.max_point);

    // 生成8个顶点
    bbox.vertices.resize(8);
    bbox.vertices[0] = pcl::PointXYZ(bbox.min_point.x, bbox.min_point.y, bbox.min_point.z);
    bbox.vertices[1] = pcl::PointXYZ(bbox.max_point.x, bbox.min_point.y, bbox.min_point.z);
    bbox.vertices[2] = pcl::PointXYZ(bbox.max_point.x, bbox.max_point.y, bbox.min_point.z);
    bbox.vertices[3] = pcl::PointXYZ(bbox.min_point.x, bbox.max_point.y, bbox.min_point.z);
    bbox.vertices[4] = pcl::PointXYZ(bbox.min_point.x, bbox.min_point.y, bbox.max_point.z);
    bbox.vertices[5] = pcl::PointXYZ(bbox.max_point.x, bbox.min_point.y, bbox.max_point.z);
    bbox.vertices[6] = pcl::PointXYZ(bbox.max_point.x, bbox.max_point.y, bbox.max_point.z);
    bbox.vertices[7] = pcl::PointXYZ(bbox.min_point.x, bbox.max_point.y, bbox.max_point.z);
}

// 修复：将参数改为 const 引用，匹配 shared_ptr 的传递方式
void addWireframeBoundingBox(const boost::shared_ptr<pcl::visualization::PCLVisualizer>& viewer,
    const BoundingBox& bbox,
    const std::string& id,
    double r = 1.0, double g = 0.0, double b = 0.0) {
    // 定义立方体的12条边
    std::vector<std::pair<int, int>> edges = {
        {0, 1}, {1, 2}, {2, 3}, {3, 0},  // 底面四条边
        {4, 5}, {5, 6}, {6, 7}, {7, 4},  // 顶面四条边
        {0, 4}, {1, 5}, {2, 6}, {3, 7}   // 连接底面和顶面的四条边
    };

    // 绘制每条边
    for (const auto& edge : edges) {
        std::string edge_id = id + "_edge_" + std::to_string(edge.first) + "_" + std::to_string(edge.second);
        viewer->addLine(bbox.vertices[edge.first], bbox.vertices[edge.second],
            r, g, b, edge_id);
        viewer->setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_LINE_WIDTH, 2, edge_id);
    }
}

void exportBoxesToCSV(const std::vector<BoundingBox>& boxes,
    const std::string& filename) {
    std::ofstream outfile(filename);
    outfile << "BoxID,VertexID,X,Y,Z,MinX,MinY,MinZ,MaxX,MaxY,MaxZ\n";

    for (size_t i = 0; i < boxes.size(); ++i) {
        const auto& box = boxes[i];
        for (size_t j = 0; j < box.vertices.size(); ++j) {
            outfile << i << "," << j << ","
                << box.vertices[j].x << "," << box.vertices[j].y << "," << box.vertices[j].z << ","
                << box.min_point.x << "," << box.min_point.y << "," << box.min_point.z << ","
                << box.max_point.x << "," << box.max_point.y << "," << box.max_point.z << "\n";
        }
    }
    outfile.close();
}

// -------------------------- 核心修改：高饱和度彩色计算（替换原getColorByHeight） --------------------------
// HSV转RGB：固定饱和度S=1.0、明度V=1.0，确保颜色鲜艳；通过z坐标动态变化色相H（0-360°）
void getHighSaturationColor(float z, float min_z, float max_z, float& r, float& g, float& b) {
    // 1. 将z坐标归一化到[0, 1]（映射到色相H的0-360°）
    float normalized_z = (z - min_z) / (max_z - min_z);
    normalized_z = std::max(0.0f, std::min(1.0f, normalized_z)); // 防止超出范围
    float hue = normalized_z * 360.0f; // 色相：0°(红)→360°(红)，覆盖全色谱（红→黄→绿→青→蓝→紫→红）

    // 2. 固定高饱和度（S=1.0）和高亮度（V=1.0），确保颜色鲜艳
    float saturation = 1.0f;
    float value = 1.0f;

    // 3. HSV转RGB（标准算法，确保色彩准确）
    float c = value * saturation;
    float x = c * (1.0f - fabs(fmod(hue / 60.0f, 2.0f) - 1.0f));
    float m = value - c;

    if (hue >= 0.0f && hue < 60.0f) {
        r = c; g = x; b = 0.0f;
    }
    else if (hue >= 60.0f && hue < 120.0f) {
        r = x; g = c; b = 0.0f;
    }
    else if (hue >= 120.0f && hue < 180.0f) {
        r = 0.0f; g = c; b = x;
    }
    else if (hue >= 180.0f && hue < 240.0f) {
        r = 0.0f; g = x; b = c;
    }
    else if (hue >= 240.0f && hue < 300.0f) {
        r = x; g = 0.0f; b = c;
    }
    else { // 300°-360°
        r = c; g = 0.0f; b = x;
    }

    // 4. 调整明度（加上m），确保最终RGB值在[0,1]
    r += m;
    g += m;
    b += m;
}

int main(int argc, char** argv) {
    // 1. 加载点云
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
    if (pcl::io::loadPCDFile<pcl::PointXYZ>("plant - Cloud.pcd", *cloud) == -1) {
        PCL_ERROR("Couldn't read input file\n");
        return -1;
    }

    // 获取点云的z轴范围，用于彩色计算（复用原逻辑）
    pcl::PointXYZ min_pt, max_pt;
    pcl::getMinMax3D(*cloud, min_pt, max_pt);
    float min_z = min_pt.z;
    float max_z = max_pt.z;

    // 2. 体素化分块（原代码不变）
    float leaf_size = 0.4f;
    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;
    voxel_grid.setInputCloud(cloud);
    voxel_grid.setLeafSize(leaf_size, leaf_size, leaf_size);

    std::unordered_map<std::string, pcl::PointCloud<pcl::PointXYZ>::Ptr> voxel_clouds;
    std::vector<BoundingBox> bounding_boxes;

    // 3. 生成体素块（原代码不变）
    for (const auto& point : cloud->points) {
        std::string voxel_id =
            std::to_string(static_cast<int>(point.x / leaf_size)) + "_" +
            std::to_string(static_cast<int>(point.y / leaf_size)) + "_" +
            std::to_string(static_cast<int>(point.z / leaf_size));

        if (voxel_clouds.find(voxel_id) == voxel_clouds.end()) {
            voxel_clouds[voxel_id] = pcl::PointCloud<pcl::PointXYZ>::Ptr(
                new pcl::PointCloud<pcl::PointXYZ>);
        }
        voxel_clouds[voxel_id]->push_back(point);
    }

    // 4. 为每个体素块计算包围盒（原代码不变）
    for (const auto& pair : voxel_clouds) {
        BoundingBox bbox;
        calculateBoundingBox(pair.second, bbox);
        bounding_boxes.push_back(bbox);
    }

    // 5. 导出包围盒数据（原代码不变）
    exportBoxesToCSV(bounding_boxes, "bounding_boxes.csv");

    // 6. 可视化（仅修改颜色计算函数调用）
    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer(
        new pcl::visualization::PCLVisualizer("3D Viewer"));
    viewer->setBackgroundColor(1.0, 1.0, 1.0); // 白色背景（原代码不变）

    // -------------------------- 修改：调用高饱和度彩色计算函数 --------------------------
    for (size_t i = 0; i < cloud->points.size(); ++i) {
        const auto& point = cloud->points[i];
        float r, g, b;
        // 替换原getColorByHeight为getHighSaturationColor
        getHighSaturationColor(point.z, min_z, max_z, r, g, b);

        std::string point_id = "point_" + std::to_string(i);
        viewer->addSphere(point, 0.015, r, g, b, point_id); // 球体大小不变（原代码不变）
    }

    // 添加线框包围盒（原代码不变）
    for (size_t i = 0; i < bounding_boxes.size(); ++i) {
        const auto& bbox = bounding_boxes[i];
        addWireframeBoundingBox(viewer, bbox, "bbox_" + std::to_string(i), 1.0, 1.0, 0.0); // 黄色线框
    }

    // 取消三维坐标系（原代码不变）
    // viewer->addCoordinateSystem(1.0); // 添加坐标系
    viewer->initCameraParameters();

    while (!viewer->wasStopped()) {
        viewer->spinOnce(100);
        boost::this_thread::sleep(boost::posix_time::microseconds(100000));
    }

    return 0;
}