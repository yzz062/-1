#include <iostream>
#include <thread>
#include <chrono>
#include <vector>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/features/boundary.h>
#include <pcl/features/normal_3d.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/filters/radius_outlier_removal.h>
#include <pcl/search/kdtree.h>

// 点云细化函数（减少细化程度，保留更多点）
pcl::PointCloud<pcl::PointXYZ>::Ptr thinCloud(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, int iterations)
{
    pcl::PointCloud<pcl::PointXYZ>::Ptr thinned_cloud(new pcl::PointCloud<pcl::PointXYZ>);
    *thinned_cloud = *cloud;

    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);

    for (int i = 0; i < iterations; ++i)
    {
        pcl::PointCloud<pcl::PointXYZ>::Ptr temp_cloud(new pcl::PointCloud<pcl::PointXYZ>);
        tree->setInputCloud(thinned_cloud);

        for (size_t j = 0; j < thinned_cloud->size(); ++j)
        {
            std::vector<int> neighbors_indices;
            std::vector<float> neighbors_distances;

            // 增大搜索半径，减少剔除的点
            if (tree->radiusSearch(j, 0.01f, neighbors_indices, neighbors_distances) > 1)
            {
                // 降低阈值，保留更多点（原先是500）
                if (neighbors_indices.size() < 500)
                {
                    temp_cloud->push_back(thinned_cloud->points[j]);
                }
            }
            else
            {
                temp_cloud->push_back(thinned_cloud->points[j]);
            }
        }

        thinned_cloud = temp_cloud;

        if (thinned_cloud->size() < 10)  // 保留更多骨架点
            break;
    }

    return thinned_cloud;
}

// 提取边界点（保留更多边界点）
pcl::PointCloud<pcl::PointXYZ>::Ptr extractBoundaryPoints(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud)
{
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_downsampled(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::VoxelGrid<pcl::PointXYZ> voxelGrid;
    voxelGrid.setInputCloud(cloud);
    // 减小体素大小，保留更多原始点（原先是0.03f）
    voxelGrid.setLeafSize(0.03f, 0.03f, 0.03f);
    voxelGrid.filter(*cloud_downsampled);

    pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
    pcl::PointCloud<pcl::Normal>::Ptr normals(new pcl::PointCloud<pcl::Normal>);
    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);

    tree->setInputCloud(cloud_downsampled);
    ne.setInputCloud(cloud_downsampled);
    ne.setSearchMethod(tree);
    // 减少法向量估计的邻域点，增加边界点识别率（原先是100）
    ne.setKSearch(30);
    ne.compute(*normals);

    pcl::BoundaryEstimation<pcl::PointXYZ, pcl::Normal, pcl::Boundary> be;
    pcl::PointCloud<pcl::Boundary>::Ptr boundaries(new pcl::PointCloud<pcl::Boundary>);

    be.setInputCloud(cloud_downsampled);
    be.setInputNormals(normals);
    be.setSearchMethod(tree);
    // 减少边界估计的邻域点，增加边界点数量（原先是100）
    be.setKSearch(40);
    be.compute(*boundaries);

    pcl::PointCloud<pcl::PointXYZ>::Ptr boundary_points(new pcl::PointCloud<pcl::PointXYZ>);
    for (size_t i = 0; i < cloud_downsampled->size(); ++i)
    {
        if (boundaries->points[i].boundary_point)
        {
            boundary_points->push_back(cloud_downsampled->points[i]);
        }
    }

    pcl::RadiusOutlierRemoval<pcl::PointXYZ> outlier_removal;
    outlier_removal.setInputCloud(boundary_points);
    // 调整离群点去除参数，保留更多点（原先是5.0）
    outlier_removal.setRadiusSearch(5.0);
    outlier_removal.setMinNeighborsInRadius(1);
    outlier_removal.filter(*boundary_points);

    return boundary_points;
}

// 计算点之间的连接关系，生成更多线段
std::vector<pcl::Vertices> computeSkeletonLines(pcl::PointCloud<pcl::PointXYZ>::Ptr skeleton, float max_distance)
{
    std::vector<pcl::Vertices> lines;
    if (skeleton->size() < 2) return lines;

    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    tree->setInputCloud(skeleton);

    for (size_t i = 0; i < skeleton->size(); ++i)
    {
        std::vector<int> neighbors_indices;
        std::vector<float> neighbors_distances;

        // 搜索更多邻近点
        if (tree->radiusSearch(i, max_distance, neighbors_indices, neighbors_distances) > 1)
        {
            int count = 0;
            // 每个点连接更多邻居（原先是2个）
            for (size_t j = 0; j < neighbors_indices.size() && count < 3; ++j)
            {
                int neighbor_idx = neighbors_indices[j];
                if (neighbor_idx > i)
                {
                    pcl::Vertices line;
                    line.vertices.push_back(i);
                    line.vertices.push_back(neighbor_idx);
                    lines.push_back(line);
                    count++;
                }
            }
        }
    }

    return lines;
}

// 显示原始点云的窗口
void visualizeOriginalCloud(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud)
{
    pcl::visualization::PCLVisualizer viewer("原始点云");
    viewer.setBackgroundColor(0, 0, 0);
    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> cloudColor(cloud, 255, 255, 255);
    viewer.addPointCloud<pcl::PointXYZ>(cloud, cloudColor, "original_cloud");
    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "original_cloud");
    viewer.initCameraParameters();
    viewer.resetCamera();

    while (!viewer.wasStopped())
    {
        viewer.spinOnce(100);
        std::this_thread::sleep_for(std::chrono::microseconds(100000));
    }
}

// 显示骨架线的窗口
    void visualizeSkeletonLines(pcl::PointCloud<pcl::PointXYZ>::Ptr skeleton, std::vector<pcl::Vertices> lines)
{
    pcl::visualization::PCLVisualizer viewer("骨架线");
    viewer.setBackgroundColor(0, 0, 0);

    // 同时显示骨架点和骨架线，方便观察
    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> skeletonColor(skeleton, 255, 0, 0);
    viewer.addPointCloud<pcl::PointXYZ>(skeleton, skeletonColor, "skeleton_points");
    viewer.setPointCloudRenderingProperties(pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1.0, "skeleton_points");

    for (size_t i = 0; i < lines.size(); ++i)
    {
        if (lines[i].vertices.size() >= 2)
        {
            int idx1 = lines[i].vertices[0];
            int idx2 = lines[i].vertices[1];
            std::string line_id = "line_" + std::to_string(i);
            viewer.addLine<pcl::PointXYZ>(skeleton->points[idx1], skeleton->points[idx2], 0.0f, 1.0f, 0.0f, line_id);
            viewer.setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_LINE_WIDTH, 2, line_id);
        }
    }

    viewer.initCameraParameters();
    viewer.resetCamera();

    while (!viewer.wasStopped())
    {
        viewer.spinOnce(100);
        std::this_thread::sleep_for(std::chrono::microseconds(100000));
    }
}

int main(int argc, char** argv)
{
    std::string inputFileName = "E:\\点云数据\\jianzhu.pcd";
    std::string outputFileName = "skeleton.pcd";

    if (argc >= 2) inputFileName = argv[1];
    if (argc >= 3) outputFileName = argv[2];

    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
    if (pcl::io::loadPCDFile<pcl::PointXYZ>(inputFileName, *cloud) == -1)
    {
        PCL_ERROR("无法读取PCD文件！\n");
        return -1;
    }

    std::cout << "成功读取点云，点数: " << cloud->size() << std::endl;

    // 提取边界点
    pcl::PointCloud<pcl::PointXYZ>::Ptr boundary_points = extractBoundaryPoints(cloud);
    std::cout << "提取边界点数量: " << boundary_points->size() << std::endl;

    // 减少迭代次数，保留更多骨架点（原先是2）
    pcl::PointCloud<pcl::PointXYZ>::Ptr skeleton = thinCloud(boundary_points, 1);
    std::cout << "骨架点数量: " << skeleton->size() << std::endl;

    // 增大最大连接距离，生成更多线段（原先是0.05f）
    std::vector<pcl::Vertices> skeleton_lines = computeSkeletonLines(skeleton, 1.0f);
    std::cout << "生成骨架线段数量: " << skeleton_lines.size() << std::endl;

    if (pcl::io::savePCDFileASCII(outputFileName, *skeleton) == -1)
    {
        PCL_ERROR("无法保存骨架点云文件！\n");
        return -1;
    }
    std::cout << "骨架点云已保存到: " << outputFileName << std::endl;

    std::thread original_cloud_thread(&visualizeOriginalCloud, cloud);
    std::thread skeleton_thread(&visualizeSkeletonLines, skeleton, skeleton_lines);

    original_cloud_thread.join();
    skeleton_thread.join();

    return 0;
}
