#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/common/common.h>
#include <fstream>
#include <vector>
#include <unordered_map>
#include <boost/thread/thread.hpp>
#include <cmath>

struct BoundingBox {
    pcl::PointXYZ min_point;
    pcl::PointXYZ max_point;
    std::vector<pcl::PointXYZ> vertices;
};

void calculateBoundingBox(const pcl::PointCloud<pcl::PointXYZ>::Ptr& cloud,
    BoundingBox& bbox) {
    pcl::getMinMax3D(*cloud, bbox.min_point, bbox.max_point);

    // Generate 8 vertices of the bounding box
    bbox.vertices.resize(8);
    bbox.vertices[0] = pcl::PointXYZ(bbox.min_point.x, bbox.min_point.y, bbox.min_point.z);
    bbox.vertices[1] = pcl::PointXYZ(bbox.max_point.x, bbox.min_point.y, bbox.min_point.z);
    bbox.vertices[2] = pcl::PointXYZ(bbox.max_point.x, bbox.max_point.y, bbox.min_point.z);
    bbox.vertices[3] = pcl::PointXYZ(bbox.min_point.x, bbox.max_point.y, bbox.min_point.z);
    bbox.vertices[4] = pcl::PointXYZ(bbox.min_point.x, bbox.min_point.y, bbox.max_point.z);
    bbox.vertices[5] = pcl::PointXYZ(bbox.max_point.x, bbox.min_point.y, bbox.max_point.z);
    bbox.vertices[6] = pcl::PointXYZ(bbox.max_point.x, bbox.max_point.y, bbox.max_point.z);
    bbox.vertices[7] = pcl::PointXYZ(bbox.min_point.x, bbox.max_point.y, bbox.max_point.z);
}

// Fix: Change parameters to const reference to match shared_ptr passing
void addWireframeBoundingBox(const boost::shared_ptr<pcl::visualization::PCLVisualizer>& viewer,
    const BoundingBox& bbox,
    const std::string& id,
    double r = 1.0, double g = 0.0, double b = 0.0) {
    // Define 12 edges of the cube
    std::vector<std::pair<int, int>> edges = {
        {0, 1}, {1, 2}, {2, 3}, {3, 0},  // Bottom face edges
        {4, 5}, {5, 6}, {6, 7}, {7, 4},  // Top face edges
        {0, 4}, {1, 5}, {2, 6}, {3, 7}   // Vertical connecting edges
    };

    // Render each edge
    for (const auto& edge : edges) {
        std::string edge_id = id + "_edge_" + std::to_string(edge.first) + "_" + std::to_string(edge.second);
        viewer->addLine(bbox.vertices[edge.first], bbox.vertices[edge.second],
            r, g, b, edge_id);
        viewer->setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_LINE_WIDTH, 2, edge_id);
    }
}

void exportBoxesToCSV(const std::vector<BoundingBox>& boxes,
    const std::string& filename) {
    std::ofstream outfile(filename);
    outfile << "BoxID,VertexID,X,Y,Z,MinX,MinY,MinZ,MaxX,MaxY,MaxZ\n";

    for (size_t i = 0; i < boxes.size(); ++i) {
        const auto& box = boxes[i];
        for (size_t j = 0; j < box.vertices.size(); ++j) {
            outfile << i << "," << j << ","
                << box.vertices[j].x << "," << box.vertices[j].y << "," << box.vertices[j].z << ","
                << box.min_point.x << "," << box.min_point.y << "," << box.min_point.z << ","
                << box.max_point.x << "," << box.max_point.y << "," << box.max_point.z << "\n";
        }
    }
    outfile.close();
}

// -------------------------- Core Modification: High Saturation Color Calculation (Replaces original getColorByHeight) --------------------------
// HSV to RGB conversion: Fixed saturation S=1.0, value V=1.0 to ensure vibrant colors; 
// Dynamic hue H (0-360°) based on z-coordinate
void getHighSaturationColor(float z, float min_z, float max_z, float& r, float& g, float& b) {
    // 1. Normalize z-coordinate to [0, 1] (mapped to hue H 0-360°)
    float normalized_z = (z - min_z) / (max_z - min_z);
    normalized_z = std::max(0.0f, std::min(1.0f, normalized_z)); // Clamp to valid range
    float hue = normalized_z * 360.0f; // Hue: 0°(red)→360°(red), covering full spectrum (red→yellow→green→cyan→blue→purple→red)

    // 2. Fixed high saturation (S=1.0) and high brightness (V=1.0) to ensure vibrant colors
    float saturation = 1.0f;
    float value = 1.0f;

    // 3. HSV to RGB conversion (standard algorithm for accurate color representation)
    float c = value * saturation;
    float x = c * (1.0f - fabs(fmod(hue / 60.0f, 2.0f) - 1.0f));
    float m = value - c;

    if (hue >= 0.0f && hue < 60.0f) {
        r = c; g = x; b = 0.0f;
    }
    else if (hue >= 60.0f && hue < 120.0f) {
        r = x; g = c; b = 0.0f;
    }
    else if (hue >= 120.0f && hue < 180.0f) {
        r = 0.0f; g = c; b = x;
    }
    else if (hue >= 180.0f && hue < 240.0f) {
        r = 0.0f; g = x; b = c;
    }
    else if (hue >= 240.0f && hue < 300.0f) {
        r = x; g = 0.0f; b = c;
    }
    else { // 300°-360°
        r = c; g = 0.0f; b = x;
    }

    // 4. Adjust brightness (add m) to ensure final RGB values are in [0,1]
    r += m;
    g += m;
    b += m;
}

int main(int argc, char** argv) {
    // 1. Load point cloud
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
    if (pcl::io::loadPCDFile<pcl::PointXYZ>("plant - Cloud.pcd", *cloud) == -1) {
        PCL_ERROR("Couldn't read input file\n");
        return -1;
    }

    // Get z-axis range of point cloud for color calculation (reusing original logic)
    pcl::PointXYZ min_pt, max_pt;
    pcl::getMinMax3D(*cloud, min_pt, max_pt);
    float min_z = min_pt.z;
    float max_z = max_pt.z;

    // 2. Voxel grid partitioning (unchanged from original code)
    float leaf_size = 0.4f;
    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;
    voxel_grid.setInputCloud(cloud);
    voxel_grid.setLeafSize(leaf_size, leaf_size, leaf_size);

    std::unordered_map<std::string, pcl::PointCloud<pcl::PointXYZ>::Ptr> voxel_clouds;
    std::vector<BoundingBox> bounding_boxes;

    // 3. Generate voxel blocks (unchanged from original code)
    for (const auto& point : cloud->points) {
        std::string voxel_id =
            std::to_string(static_cast<int>(point.x / leaf_size)) + "_" +
            std::to_string(static_cast<int>(point.y / leaf_size)) + "_" +
            std::to_string(static_cast<int>(point.z / leaf_size));

        if (voxel_clouds.find(voxel_id) == voxel_clouds.end()) {
            voxel_clouds[voxel_id] = pcl::PointCloud<pcl::PointXYZ>::Ptr(
                new pcl::PointCloud<pcl::PointXYZ>);
        }
        voxel_clouds[voxel_id]->push_back(point);
    }

    // 4. Compute bounding box for each voxel block (unchanged from original code)
    for (const auto& pair : voxel_clouds) {
        BoundingBox bbox;
        calculateBoundingBox(pair.second, bbox);
        bounding_boxes.push_back(bbox);
    }

    // 5. Export bounding box data (unchanged from original code)
    exportBoxesToCSV(bounding_boxes, "bounding_boxes.csv");

    // 6. Visualization (only modifying color calculation function call)
    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer(
        new pcl::visualization::PCLVisualizer("3D Viewer"));
    viewer->setBackgroundColor(1.0, 1.0, 1.0); // White background (unchanged from original code)

    // -------------------------- Modification: Call high saturation color calculation function --------------------------
    for (size_t i = 0; i < cloud->points.size(); ++i) {
        const auto& point = cloud->points[i];
        float r, g, b;
        // Replace original getColorByHeight with getHighSaturationColor
        getHighSaturationColor(point.z, min_z, max_z, r, g, b);

        std::string point_id = "point_" + std::to_string(i);
        viewer->addSphere(point, 0.015, r, g, b, point_id); // Sphere size unchanged (unchanged from original code)
    }

    // Add wireframe bounding boxes (unchanged from original code)
    for (size_t i = 0; i < bounding_boxes.size(); ++i) {
        const auto& bbox = bounding_boxes[i];
        addWireframeBoundingBox(viewer, bbox, "bbox_" + std::to_string(i), 1.0, 1.0, 0.0); // Yellow wireframe
    }

    // Disable 3D coordinate system (unchanged from original code)
    // viewer->addCoordinateSystem(1.0); // Add coordinate system
    viewer->initCameraParameters();

    while (!viewer->wasStopped()) {
        viewer->spinOnce(100);
        boost::this_thread::sleep(boost::posix_time::microseconds(100000));
    }

    return 0;
}